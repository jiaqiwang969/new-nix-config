#---------------------------------------------------------------------------
# Prompt
#---------------------------------------------------------------------------
RED="\033[0;31m"
BROWN="\033[0;33m"
GREY="\033[0;97m"
GREEN="\033[0;32m"
BLUE="\033[0;34m"
PS_CLEAR="\033[0m"
SCREEN_ESC="\033k\033\134"

COLOR1="${BLUE}"
COLOR2="${BLUE}"
P="\$"

prompt_simple() {
    unset PROMPT_COMMAND
    PS1="\W\$(parse_git_branch) → "
    PS2="> "
}

prompt_compact() {
    unset PROMPT_COMMAND
    PS1="${COLOR1}${P}${PS_CLEAR} "
    PS2="> "
}

prompt_color() {
    PS1="${GREEN}\W\$(parse_git_branch) → ${GREY}"
    PS2="\033[33;1mcontinue \033[0m\033[1m> "
}

parse_git_branch() {
    [ -d .git ] || return 1
    git symbolic-ref HEAD 2> /dev/null | sed 's#\(.*\)\/\([^\/]*\)$# \2#'
}

# Set default prompt if interactive
test -n "$PS1" &&
prompt_color

# Ghostty setup. For testing.
# if [ -n "$GHOSTTY_RESOURCES_DIR" ]; then
#     builtin source "${GHOSTTY_RESOURCES_DIR}/shell-integration/bash/ghostty.bash"
# fi

#-------------------------------------------------------------------------------
# Safe rm: intercepts ALL rm calls including /bin/rm, env rm, etc.
#-------------------------------------------------------------------------------
function rm() {
    # Block catastrophically dangerous patterns
    for arg in "$@"; do
        expanded="${arg/#\~/$HOME}"
        real=""
        if [ -e "$expanded" ]; then
            real="$(cd "$expanded" 2>/dev/null && pwd)"
        fi
        if [ "$expanded" = "$HOME" ] \
            || [ "$expanded" = "$HOME/" ] \
            || [ "$expanded" = "/" ] \
            || [ "$real" = "$HOME" ] \
            || [ "$real" = "/" ]; then
            echo "" >&2
            echo "╔══════════════════════════════════════════════════════╗" >&2
            echo "║  !! BLOCKED: rm targeting HOME or root directory !!  ║" >&2
            echo "║  This command would have deleted everything.         ║" >&2
            echo "║  Use __purge_rm if you truly know what you're doing. ║" >&2
            echo "╚══════════════════════════════════════════════════════╝" >&2
            echo "" >&2
            return 1
        fi
    done
    # Delegate to the safe-rm wrapper in PATH (moves to trash)
    command rm "$@"
}
export -f rm
